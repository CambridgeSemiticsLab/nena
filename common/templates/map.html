{#  optional parameters taken by this template:                                                       #}
{#  - `map_data_json` is a json string containing a plottable set of data consumed by `L.geoJSON()`   #}
{#  - `map_center` is a two value list (longitude, latitude)                                          #}

<div id="map">
  <div class="key">
    <span class="icon_base icon_C">Christian</span> &nbsp;
    <span class="icon_base icon_J">Jewish</span>
  </div>
</div>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.0.1/dist/leaflet.js"></script>
<script src="/static/js/borders.js"></script>
<script>

    var normalmap = L.tileLayer('https://stamen-tiles-{s}.a.ssl.fastly.net/terrain-background/{z}/{x}/{y}.{ext}', {
            attribution: '&copy; <a href="http://stamen.com">Stamen Design</a>, <a href="http://creativecommons.org/licenses/by/3.0">CC BY 3.0</a> &mdash; &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            minZoom: 6,
            maxZoom: 11,
            ext: 'png' });
    var cities = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_only_labels/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            minZoom: 6,
            maxZoom: 11,
            ext: 'png' });
    var cities_and_terrain = new L.LayerGroup([normalmap, cities])

    var printmap = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            minZoom: 6,
            maxZoom: 11 });

    var baseLayers = {
        "Print view": printmap,
        "Normal view": cities_and_terrain,
    };

    var center = [{{map_center.0|default:'37'}}, {{map_center.1|default:'45'}}];
    var map     = L.map('map',{layers: [cities_and_terrain], center: center, zoom: 7, maxBoundsViscosity: 0.9});
    var borders = L.geoJSON(country_borders, {style: function(feature) { return { className: feature.properties.class }} }).addTo(map);

    map.on('baselayerchange', function(e) {
      $('#map').toggleClass('print')
    });

    // Process our map data points, grouping into layers by point.properties.group
    // if this doesn't exist stick them in a single layer called "points"
    json_data = {{map_data_json|safe}};
    all_names = json_data.map(point => point.properties.group)
                         .filter(x => typeof x !== 'undefined')
    group_names = Array.from(new Set(all_names))

    if( !group_names.length ){
      group_names = ['points']
    }

    groups = {}
    for(i in group_names){
      var group = L.featureGroup();
      group.addTo(map);
      groups[group_names[i]] = group;
    }

    // This provides a lookup function to convert from a geoJSON item to a Leaflet Marker
    dataLayerOptions = {pointToLayer: function (feature, latlng) {
        var props = feature.properties;
        class_list = props.community ? 'icon_base icon_' + props.community : 'default-icon';
        if(props.focus){
            class_list += ' icon_focus';
        }
        if(typeof props.group_number !== 'undefined'){
          if(group_names.length < 2)
          {
            class_list += ' only_group';
          }else{
            class_list += ' group_'+props.group_number;
          }
        }
        myIcon   = L.divIcon({iconSize: L.point(7, 7), className: class_list });
        myMarker = L.marker(latlng, { icon: myIcon });

        tooltip_options = {
            offset: L.point(0, -10),
            direction: 'top',
            className: 'map_tooltip',
            permanent: props.focus ? true : false,
        }
        if( props.type == 'entry' ){
          tooltip_content = props.entry + '<br><span style="font-size:60%">'+props.dialect+'</span>';
        }else{
          tooltip_content = props.dialect;
        }
        myMarker.bindTooltip(tooltip_content, tooltip_options);

        if(props.url){
            myMarker.on("click", function(){window.location = props.url});
        }
        return myMarker;
    }};

    for(i in json_data){
      marker_data = json_data[i]
      group_name = marker_data.properties.group || 'points';
      marker_data['properties']['group_number'] = group_names.indexOf(group_name);
      marker = L.geoJSON(marker_data, dataLayerOptions)
      marker.addTo(groups[group_name]);
    }

    if(group_names.length > 1){
      prefixed_groups = {};
      group_counter = 0;
      for(group_name in groups){
        group = groups[group_name]
        prefixed_name = '<span class="label group_'+group_counter+'"></span> '+group_name+' <i>('+group.getLayers().length+')</i>';
        prefixed_groups[prefixed_name] = group;
        group_counter++;
      }
    }else{
      prefixed_groups = groups;
    }
    L.control.layers(baseLayers, prefixed_groups).addTo(map);



    markers = L.geoJSON(json_data, dataLayerOptions)
    map.setMaxBounds(markers.getBounds().pad(.2));


    /* {# not sure this is doing anything, to remove if we don't implement label culling on zoom #}
    var show_label_zoom = 3; // zoom level threshold for showing/hiding labels
    var labels_visible = true;
    function show_hide_labels() {
        var cur_zoom = map.getZoom();
        if(labels_visible && cur_zoom < show_label_zoom) {
            labels_visible = false;
            map.eachLayer(function (layer) {
                layer.hideLabel && layer.hideLabel();
            });
        }
        else if(!labels_visible && cur_zoom >= show_label_zoom) {
            labels_visible = true;
            map.eachLayer(function (layer) {
                layer.showLabel && layer.showLabel();
            });
        }
    }
    map.on('zoomend', show_hide_labels);
    */
</script>
